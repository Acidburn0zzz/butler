package buse

import (
	"time"

	"github.com/itchio/butler/cmd/launch/manifest"
	"github.com/itchio/butler/configurator"
	"github.com/itchio/butler/installer/bfs"
	itchio "github.com/itchio/go-itchio"
)

// must be kept in sync with clients, see for example
// https://github.com/itchio/node-butler

//----------------------------------------------------------------------
// Version
//----------------------------------------------------------------------

// Retrieves the version of the butler instance the client
// is connected to.
//
// This endpoint is meant to gather information when reporting
// issues, rather than feature sniffing. Conforming clients should
// automatically download new versions of butler, see [Updating](#updating).
//
// @name Version.Get
// @category Utilities
// @tags Offline
type VersionGetParams struct{}

type VersionGetResult struct {
	// Something short, like `v8.0.0`
	Version string `json:"version"`

	// Something long, like `v8.0.0, built on Aug 27 2017 @ 01:13:55, ref d833cc0aeea81c236c81dffb27bc18b2b8d8b290`
	VersionString string `json:"versionString"`
}

//----------------------------------------------------------------------
// Game
//----------------------------------------------------------------------

// Finds uploads compatible with the current runtime, for a given game
//
// @name Game.FindUploads
// @category Install
type GameFindUploadsParams struct {
	// Which game to find uploads for
	Game *itchio.Game `json:"game"`
	// The credentials to use to list uploads
	Credentials *GameCredentials `json:"credentials"`
}

type GameFindUploadsResult struct {
	// A list of uploads that were found to be compatible.
	Uploads []*itchio.Upload `json:"uploads"`
}

//----------------------------------------------------------------------
// Operation
//----------------------------------------------------------------------

type Operation string

var (
	OperationInstall   Operation = "install"
	OperationUninstall Operation = "uninstall"
)

// Start a new operation (installing or uninstalling).
//
// @name Operation.Start
// @category Install
// @tags Cancellable
type OperationStartParams struct {
	// A UUID, generated by the client, used for referring to the
	// task when cancelling it, for instance.
	ID string `json:"id"`

	// A folder that butler can use to store temporary files, like
	// partial downloads, checkpoint files, etc.
	StagingFolder string `json:"stagingFolder"`

	// Which operation to perform
	Operation Operation `json:"operation"`

	// Must be set if Operation is `install`
	InstallParams *InstallParams `json:"installParams,omitempty"`

	// Must be set if Operation is `uninstall`
	UninstallParams *UninstallParams `json:"uninstallParams,omitempty"`
}

// Attempt to gracefully cancel an ongoing operation.
//
// @name Operation.Cancel
// @category Install
type OperationCancelParams struct {
	// The UUID of the task to cancel, as passed to [Operation.Start](#operationstart-request)
	ID string `json:"id"`
}

type OperationCancelResult struct{}

// InstallParams contains all the parameters needed to perform
// an installation for a game.
// @category Install
type InstallParams struct {
	// Which game to install
	Game *itchio.Game `json:"game"`

	// An absolute path where to install the game
	InstallFolder string `json:"installFolder"`

	// Which upload to install
	// @optional
	Upload *itchio.Upload `json:"upload"`

	// Which build to install
	// @optional
	Build *itchio.Build `json:"build"`

	// Which credentials to use to install the game
	Credentials *GameCredentials `json:"credentials"`

	// If true, do not run windows installers, just extract
	// whatever to the install folder.
	// @optional
	IgnoreInstallers bool `json:"ignoreInstallers,omitempty"`
}

// UninstallParams contains all the parameters needed to perform
// an uninstallation for a game.
// @category Install
type UninstallParams struct {
	InstallFolder string `json:"installFolder"`
}

// GameCredentials contains all the credentials required to make API requests
// including the download key if any
// @category General
type GameCredentials struct {
	Server      string `json:"server"`
	APIKey      string `json:"apiKey"`
	DownloadKey int64  `json:"downloadKey"`
}

// Asks the user to pick between multiple available uploads
//
// @category Install
// @tags Dialog
type PickUploadParams struct {
	Uploads []*itchio.Upload `json:"uploads"`
}

type PickUploadResult struct {
	Index int64 `json:"index"`
}

// Retrieves existing receipt information for an install
//
// @category Install
// @tags Deprecated
type GetReceiptParams struct {
	// muffin
}

type GetReceiptResult struct {
	Receipt *bfs.Receipt `json:"receipt"`
}

// Sent periodically to inform on the current state an operation

// @name Operation.Progress
// @category Install
type OperationProgressNotification struct {
	Progress float64 `json:"progress"`
	ETA      float64 `json:"eta"`
	BPS      float64 `json:"bps"`
}

type TaskReason string

const (
	TaskReasonInstall   TaskReason = "install"
	TaskReasonUninstall TaskReason = "uninstall"
)

type TaskType string

const (
	TaskTypeDownload  TaskType = "download"
	TaskTypeInstall   TaskType = "install"
	TaskTypeUninstall TaskType = "uninstall"
	TaskTypeUpdate    TaskType = "update"
	TaskTypeHeal      TaskType = "heal"
)

type TaskStartedNotification struct {
	Reason    TaskReason     `json:"reason"`
	Type      TaskType       `json:"type"`
	Game      *itchio.Game   `json:"game"`
	Upload    *itchio.Upload `json:"upload"`
	Build     *itchio.Build  `json:"build,omitempty"`
	TotalSize int64          `json:"totalSize,omitempty"`
}

type TaskSucceededNotification struct {
	Type TaskType `json:"type"`
	// If the task installed something, then this contains
	// info about the game, upload, build that were installed
	InstallResult *InstallResult `json:"installResult,omitempty"`
}

type OperationResult struct{}

type InstallResult struct {
	Game   *itchio.Game   `json:"game"`
	Upload *itchio.Upload `json:"upload"`
	Build  *itchio.Build  `json:"build"`
	// TODO: verdict ?
}

//----------------------------------------------------------------------
// CheckUpdate
//----------------------------------------------------------------------

// Looks for one or more game updates
type CheckUpdateParams struct {
	Items []*CheckUpdateItem `json:"items"`
}

type CheckUpdateItem struct {
	ItemID      string           `json:"itemId"`
	InstalledAt string           `json:"installedAt"`
	Game        *itchio.Game     `json:"game"`
	Upload      *itchio.Upload   `json:"upload"`
	Build       *itchio.Build    `json:"build,omitempty"`
	Credentials *GameCredentials `json:"credentials"`
}

type CheckUpdateResult struct {
	Updates  []*GameUpdate `json:"updates"`
	Warnings []string      `json:"warnings"`
}

type GameUpdateAvailableNotification struct {
	Update *GameUpdate `json:"update"`
}

type GameUpdate struct {
	ItemID string         `json:"itemId"`
	Game   *itchio.Game   `json:"game"`
	Upload *itchio.Upload `json:"upload"`
	Build  *itchio.Build  `json:"build"`
}

//----------------------------------------------------------------------
// Launch
//----------------------------------------------------------------------

type LaunchParams struct {
	InstallFolder string                `json:"installFolder"`
	Game          *itchio.Game          `json:"game"`
	Upload        *itchio.Upload        `json:"upload"`
	Build         *itchio.Build         `json:"build"`
	Verdict       *configurator.Verdict `json:"verdict"`

	PrereqsDir   string `json:"prereqsDir"`
	ForcePrereqs bool   `json:"forcePrereqs,omitempty"`

	Sandbox bool `json:"sandbox,omitempty"`

	// Used for subkeying
	Credentials *GameCredentials `json:"credentials"`
}

type LaunchResult struct {
}

type LaunchRunningNotification struct{}

type LaunchExitedNotification struct{}

// Pick a manifest action to launch, see [itch app manifests](https://itch.io/docs/itch/integrating/manifest.html)
//
// @tags Dialogs
type PickManifestActionParams struct {
	Actions []*manifest.Action `json:"actions"`
}

type PickManifestActionResult struct {
	Name string `json:"name"`
}

type ShellLaunchParams struct {
	ItemPath string `json:"itemPath"`
}

type ShellLaunchResult struct {
}

type HTMLLaunchParams struct {
	RootFolder string `json:"rootFolder"`
	IndexPath  string `json:"indexPath"`

	Args []string          `json:"args"`
	Env  map[string]string `json:"env"`
}

type HTMLLaunchResult struct {
}

type URLLaunchParams struct {
	URL string `json:"url"`
}

type URLLaunchResult struct{}

type SaveVerdictParams struct {
	Verdict *configurator.Verdict `json:"verdict"`
}
type SaveVerdictResult struct{}

type AllowSandboxSetupParams struct{}

type AllowSandboxSetupResponse struct {
	Allow bool `json:"allow"`
}

type PrereqsStartedNotification struct {
	Tasks map[string]*PrereqTask `json:"tasks"`
}

type PrereqTask struct {
	FullName string `json:"fullName"`
	Order    int    `json:"order"`
}

type PrereqStatus string

const (
	PrereqStatusPending     PrereqStatus = "pending"
	PrereqStatusDownloading PrereqStatus = "downloading"
	PrereqStatusReady       PrereqStatus = "ready"
	PrereqStatusInstalling  PrereqStatus = "installing"
	PrereqStatusDone        PrereqStatus = "done"
)

type PrereqsTaskStateNotification struct {
	Name     string       `json:"name"`
	Status   PrereqStatus `json:"status"`
	Progress float64      `json:"progress"`
	ETA      float64      `json:"eta"`
	BPS      float64      `json:"bps"`
}

type PrereqsEndedNotification struct {
}

type PrereqsFailedParams struct {
	Error      string `json:"error"`
	ErrorStack string `json:"errorStack"`
}

type PrereqsFailedResult struct {
	Continue bool `json:"continue"`
}

//----------------------------------------------------------------------
// CleanDownloads
//----------------------------------------------------------------------

// CleanDownloads.Search
type CleanDownloadsSearchParams struct {
	// A list of folders to scan for potential subfolders to clean up
	Roots []string `json:"roots"`
	// A list of subfolders to not consider when cleaning
	// (staging folders for in-progress downloads)
	Whitelist []string `json:"whitelist"`
}

type CleanDownloadsSearchResult struct {
	Entries []*CleanDownloadsEntry `json:"entries"`
}

type CleanDownloadsEntry struct {
	Path string `json:"path"`
	Size int64  `json:"size"`
}

type CleanDownloadsApplyParams struct {
	Entries []*CleanDownloadsEntry `json:"entries"`
}

type CleanDownloadsApplyResult struct{}

//----------------------------------------------------------------------
// Misc.
//----------------------------------------------------------------------

// Log
type LogNotification struct {
	Level   string `json:"level"`
	Message string `json:"message"`
}

// Test.DoubleTwice
type TestDoubleTwiceRequest struct {
	Number int64 `json:"number"`
}

// Result for Test.DoubleTwice
type TestDoubleTwiceResult struct {
	Number int64 `json:"number"`
}

// Test.Double
type TestDoubleRequest struct {
	Number int64 `json:"number"`
}

// Result for Test.Double
type TestDoubleResult struct {
	Number int64 `json:"number"`
}

const (
	CodeOperationCancelled = 499
	CodeOperationAborted   = 410
)

// Dates

func FromDateTime(s string) (time.Time, error) {
	return time.Parse(time.RFC3339, s)
}

func ToDateTime(t time.Time) string {
	return t.Format(time.RFC3339)
}
