{
  "requests": [
    {
      "method": "Handshake",
      "doc": "",
      "caller": "server",
      "params": {
        "fields": [
          {
            "name": "message",
            "doc": "",
            "type": "string"
          }
        ]
      },
      "result": {
        "fields": [
          {
            "name": "signature",
            "doc": "",
            "type": "string"
          }
        ]
      }
    },
    {
      "method": "Version.Get",
      "doc": "Retrieves the version of the butler instance the client\nis connected to.\n\nThis endpoint is meant to gather information when reporting\nissues, rather than feature sniffing. Conforming clients should\nautomatically download new versions of butler, see the **Updating** section.",
      "caller": "client",
      "params": {
        "fields": null
      },
      "result": {
        "fields": [
          {
            "name": "version",
            "doc": "Something short, like `v8.0.0`",
            "type": "string"
          },
          {
            "name": "versionString",
            "doc": "Something long, like `v8.0.0, built on Aug 27 2017 @ 01:13:55, ref d833cc0aeea81c236c81dffb27bc18b2b8d8b290`",
            "type": "string"
          }
        ]
      }
    },
    {
      "method": "Network.SetSimulateOffline",
      "doc": "",
      "caller": "client",
      "params": {
        "fields": [
          {
            "name": "enabled",
            "doc": "If true, all operations after this point will behave\nas if there were no network connections",
            "type": "boolean"
          }
        ]
      },
      "result": {
        "fields": null
      }
    },
    {
      "method": "Network.SetBandwidthThrottle",
      "doc": "",
      "caller": "client",
      "params": {
        "fields": [
          {
            "name": "enabled",
            "doc": "If true, will limit. If false, will clear any bandwidth throttles in place",
            "type": "boolean"
          },
          {
            "name": "rate",
            "doc": "The target bandwidth, in kbps",
            "type": "number"
          }
        ]
      },
      "result": {
        "fields": null
      }
    },
    {
      "method": "Profile.List",
      "doc": "Lists remembered profiles",
      "caller": "client",
      "params": {
        "fields": null
      },
      "result": {
        "fields": [
          {
            "name": "profiles",
            "doc": "A list of remembered profiles",
            "type": "Profile[]"
          }
        ]
      }
    },
    {
      "method": "Profile.LoginWithPassword",
      "doc": "Add a new profile by password login",
      "caller": "client",
      "params": {
        "fields": [
          {
            "name": "username",
            "doc": "The username (or e-mail) to use for login",
            "type": "string"
          },
          {
            "name": "password",
            "doc": "The password to use",
            "type": "string"
          }
        ]
      },
      "result": {
        "fields": [
          {
            "name": "profile",
            "doc": "Information for the new profile, now remembered",
            "type": "Profile"
          },
          {
            "name": "cookie",
            "doc": "Profile cookie for website",
            "type": "Map\u003cstring, string\u003e"
          }
        ]
      }
    },
    {
      "method": "Profile.LoginWithAPIKey",
      "doc": "Add a new profile by API key login. This can be used\nfor integration tests, for example. Note that no cookies\nare returned for this kind of login.",
      "caller": "client",
      "params": {
        "fields": [
          {
            "name": "apiKey",
            "doc": "The API token to use",
            "type": "string"
          }
        ]
      },
      "result": {
        "fields": [
          {
            "name": "profile",
            "doc": "Information for the new profile, now remembered",
            "type": "Profile"
          }
        ]
      }
    },
    {
      "method": "Profile.RequestCaptcha",
      "doc": "Ask the user to solve a captcha challenge\nSent during @@ProfileLoginWithPasswordParams if certain\nconditions are met.",
      "caller": "server",
      "params": {
        "fields": [
          {
            "name": "recaptchaUrl",
            "doc": "Address of page containing a recaptcha widget",
            "type": "string"
          }
        ]
      },
      "result": {
        "fields": [
          {
            "name": "recaptchaResponse",
            "doc": "The response given by recaptcha after it's been filled",
            "type": "string"
          }
        ]
      }
    },
    {
      "method": "Profile.RequestTOTP",
      "doc": "Ask the user to provide a TOTP token.\nSent during @@ProfileLoginWithPasswordParams if the user has\ntwo-factor authentication enabled.",
      "caller": "server",
      "params": {
        "fields": null
      },
      "result": {
        "fields": [
          {
            "name": "code",
            "doc": "The TOTP code entered by the user",
            "type": "string"
          }
        ]
      }
    },
    {
      "method": "Profile.UseSavedLogin",
      "doc": "Use saved login credentials to validate a profile.",
      "caller": "client",
      "params": {
        "fields": [
          {
            "name": "profileId",
            "doc": "",
            "type": "number"
          }
        ]
      },
      "result": {
        "fields": [
          {
            "name": "profile",
            "doc": "Information for the now validated profile",
            "type": "Profile"
          }
        ]
      }
    },
    {
      "method": "Profile.Forget",
      "doc": "Forgets a remembered profile - it won't appear in the\n@@ProfileListParams results anymore.",
      "caller": "client",
      "params": {
        "fields": [
          {
            "name": "profileId",
            "doc": "",
            "type": "number"
          }
        ]
      },
      "result": {
        "fields": [
          {
            "name": "success",
            "doc": "True if the profile did exist (and was successfully forgotten)",
            "type": "boolean"
          }
        ]
      }
    },
    {
      "method": "Profile.Data.Put",
      "doc": "Stores some data associated to a profile, by key.",
      "caller": "client",
      "params": {
        "fields": [
          {
            "name": "profileId",
            "doc": "",
            "type": "number"
          },
          {
            "name": "key",
            "doc": "",
            "type": "string"
          },
          {
            "name": "value",
            "doc": "",
            "type": "string"
          }
        ]
      },
      "result": {
        "fields": null
      }
    },
    {
      "method": "Profile.Data.Get",
      "doc": "Retrieves some data associated to a profile, by key.",
      "caller": "client",
      "params": {
        "fields": [
          {
            "name": "profileId",
            "doc": "",
            "type": "number"
          },
          {
            "name": "key",
            "doc": "",
            "type": "string"
          }
        ]
      },
      "result": {
        "fields": [
          {
            "name": "ok",
            "doc": "True if the value existed",
            "type": "boolean"
          },
          {
            "name": "value",
            "doc": "",
            "type": "string"
          }
        ]
      }
    },
    {
      "method": "Search.Games",
      "doc": "Searches for games. Returns data from the local\ndatabase and the API, via @@SearchGamesYieldNotification.",
      "caller": "client",
      "params": {
        "fields": [
          {
            "name": "profileId",
            "doc": "",
            "type": "number"
          },
          {
            "name": "query",
            "doc": "",
            "type": "string"
          }
        ]
      },
      "result": {
        "fields": null
      }
    },
    {
      "method": "Search.Users",
      "doc": "Searches for users. Returns data from the local\ndatabase and the API, via @@SearchUsersYieldNotification.",
      "caller": "client",
      "params": {
        "fields": [
          {
            "name": "profileId",
            "doc": "",
            "type": "number"
          },
          {
            "name": "query",
            "doc": "",
            "type": "string"
          }
        ]
      },
      "result": {
        "fields": null
      }
    },
    {
      "method": "Fetch.Game",
      "doc": "Fetches information for an itch.io game.",
      "caller": "client",
      "params": {
        "fields": [
          {
            "name": "gameId",
            "doc": "Identifier of game to look for",
            "type": "number"
          },
          {
            "name": "fresh",
            "doc": "Force an API request",
            "type": "boolean"
          }
        ]
      },
      "result": {
        "fields": [
          {
            "name": "game",
            "doc": "Game info",
            "type": "Game"
          },
          {
            "name": "stale",
            "doc": "Marks that a request should be issued\nafterwards with 'Fresh' set",
            "type": "boolean"
          }
        ]
      }
    },
    {
      "method": "Fetch.User",
      "doc": "Fetches information for an itch.io user.",
      "caller": "client",
      "params": {
        "fields": [
          {
            "name": "userId",
            "doc": "Identifier of the user to look for",
            "type": "number"
          },
          {
            "name": "profileId",
            "doc": "Profile to use to look upser",
            "type": "number"
          },
          {
            "name": "fresh",
            "doc": "Force an API request",
            "type": "boolean"
          }
        ]
      },
      "result": {
        "fields": [
          {
            "name": "user",
            "doc": "User info",
            "type": "User"
          },
          {
            "name": "stale",
            "doc": "Marks that a request should be issued\nafterwards with 'Fresh' set",
            "type": "boolean"
          }
        ]
      }
    },
    {
      "method": "Fetch.Sale",
      "doc": "Fetches the best current *locally cached* sale for a given\ngame.",
      "caller": "client",
      "params": {
        "fields": [
          {
            "name": "gameId",
            "doc": "Identifier of the game for which to look for a sale",
            "type": "number"
          }
        ]
      },
      "result": {
        "fields": [
          {
            "name": "sale",
            "doc": "",
            "type": "Sale"
          }
        ]
      }
    },
    {
      "method": "Fetch.Collection",
      "doc": "Fetch a collection's title, gamesCount, etc.\nbut not its games.",
      "caller": "client",
      "params": {
        "fields": [
          {
            "name": "profileId",
            "doc": "Profile to use to fetch collection",
            "type": "number"
          },
          {
            "name": "collectionId",
            "doc": "Collection to fetch",
            "type": "number"
          },
          {
            "name": "fresh",
            "doc": "Force an API request before replying.\nUsually set after getting 'stale' in the response.",
            "type": "boolean"
          }
        ]
      },
      "result": {
        "fields": [
          {
            "name": "collection",
            "doc": "Collection info",
            "type": "Collection"
          },
          {
            "name": "stale",
            "doc": "True if the info was from local DB and\nit should be re-queried using \"Fresh\"",
            "type": "boolean"
          }
        ]
      }
    },
    {
      "method": "Fetch.Collection.Games",
      "doc": "Fetches information about a collection and the games it\ncontains.",
      "caller": "client",
      "params": {
        "fields": [
          {
            "name": "profileId",
            "doc": "Profile to use to fetch collection",
            "type": "number"
          },
          {
            "name": "collectionId",
            "doc": "Identifier of the collection to look for",
            "type": "number"
          },
          {
            "name": "limit",
            "doc": "Maximum number of games to return at a time.",
            "type": "number"
          },
          {
            "name": "search",
            "doc": "When specified only shows game titles that contain this string",
            "type": "string"
          },
          {
            "name": "sortBy",
            "doc": "Criterion to sort by",
            "type": "string"
          },
          {
            "name": "filters",
            "doc": "Filters",
            "type": "CollectionGamesFilters"
          },
          {
            "name": "reverse",
            "doc": "",
            "type": "boolean"
          },
          {
            "name": "cursor",
            "doc": "Used for pagination, if specified",
            "type": "Cursor"
          },
          {
            "name": "fresh",
            "doc": "If set, will force fresh data",
            "type": "boolean"
          }
        ]
      },
      "result": {
        "fields": [
          {
            "name": "items",
            "doc": "Requested games for this collection",
            "type": "CollectionGame[]"
          },
          {
            "name": "nextCursor",
            "doc": "Use to fetch the next 'page' of results",
            "type": "Cursor"
          },
          {
            "name": "stale",
            "doc": "If true, re-issue request with 'Fresh'",
            "type": "boolean"
          }
        ]
      }
    },
    {
      "method": "Fetch.ProfileCollections",
      "doc": "Lists collections for a profile. Does not contain\ngames.",
      "caller": "client",
      "params": {
        "fields": [
          {
            "name": "profileId",
            "doc": "Profile for which to fetch collections",
            "type": "number"
          },
          {
            "name": "limit",
            "doc": "Maximum number of collections to return at a time.",
            "type": "number"
          },
          {
            "name": "cursor",
            "doc": "Used for pagination, if specified",
            "type": "Cursor"
          },
          {
            "name": "fresh",
            "doc": "If set, will force fresh data",
            "type": "boolean"
          }
        ]
      },
      "result": {
        "fields": [
          {
            "name": "items",
            "doc": "Collections belonging to the profile",
            "type": "Collection[]"
          },
          {
            "name": "nextCursor",
            "doc": "Used to fetch the next page",
            "type": "Cursor"
          },
          {
            "name": "stale",
            "doc": "If true, re-issue request with \"Fresh\"",
            "type": "boolean"
          }
        ]
      }
    },
    {
      "method": "Fetch.ProfileGames",
      "doc": "",
      "caller": "client",
      "params": {
        "fields": [
          {
            "name": "profileId",
            "doc": "Profile for which to fetch games",
            "type": "number"
          },
          {
            "name": "limit",
            "doc": "Maximum number of items to return at a time.",
            "type": "number"
          },
          {
            "name": "search",
            "doc": "When specified only shows game titles that contain this string",
            "type": "string"
          },
          {
            "name": "sortBy",
            "doc": "Criterion to sort by",
            "type": "string"
          },
          {
            "name": "filters",
            "doc": "Filters",
            "type": "ProfileGameFilters"
          },
          {
            "name": "reverse",
            "doc": "",
            "type": "boolean"
          },
          {
            "name": "cursor",
            "doc": "Used for pagination, if specified",
            "type": "Cursor"
          },
          {
            "name": "fresh",
            "doc": "If set, will force fresh data",
            "type": "boolean"
          }
        ]
      },
      "result": {
        "fields": [
          {
            "name": "items",
            "doc": "Profile games",
            "type": "ProfileGame[]"
          },
          {
            "name": "nextCursor",
            "doc": "Used to fetch the next page",
            "type": "Cursor"
          },
          {
            "name": "stale",
            "doc": "If true, re-issue request with \"Fresh\"",
            "type": "boolean"
          }
        ]
      }
    },
    {
      "method": "Fetch.ProfileOwnedKeys",
      "doc": "",
      "caller": "client",
      "params": {
        "fields": [
          {
            "name": "profileId",
            "doc": "Profile to use to fetch game",
            "type": "number"
          },
          {
            "name": "limit",
            "doc": "Maximum number of collections to return at a time.",
            "type": "number"
          },
          {
            "name": "search",
            "doc": "When specified only shows game titles that contain this string",
            "type": "string"
          },
          {
            "name": "sortBy",
            "doc": "Criterion to sort by",
            "type": "string"
          },
          {
            "name": "filters",
            "doc": "Filters",
            "type": "ProfileOwnedKeysFilters"
          },
          {
            "name": "reverse",
            "doc": "",
            "type": "boolean"
          },
          {
            "name": "cursor",
            "doc": "Used for pagination, if specified",
            "type": "Cursor"
          },
          {
            "name": "fresh",
            "doc": "If set, will force fresh data",
            "type": "boolean"
          }
        ]
      },
      "result": {
        "fields": [
          {
            "name": "items",
            "doc": "Download keys fetched for profile",
            "type": "DownloadKey[]"
          },
          {
            "name": "nextCursor",
            "doc": "Used to fetch the next page",
            "type": "Cursor"
          },
          {
            "name": "stale",
            "doc": "If true, re-issue request with \"Fresh\"",
            "type": "boolean"
          }
        ]
      }
    },
    {
      "method": "Fetch.Commons",
      "doc": "",
      "caller": "client",
      "params": {
        "fields": null
      },
      "result": {
        "fields": [
          {
            "name": "downloadKeys",
            "doc": "",
            "type": "DownloadKeySummary[]"
          },
          {
            "name": "caves",
            "doc": "",
            "type": "CaveSummary[]"
          },
          {
            "name": "installLocations",
            "doc": "",
            "type": "InstallLocationSummary[]"
          }
        ]
      }
    },
    {
      "method": "Fetch.Caves",
      "doc": "Retrieve info for all caves.",
      "caller": "client",
      "params": {
        "fields": [
          {
            "name": "limit",
            "doc": "Maximum number of caves to return at a time.",
            "type": "number"
          },
          {
            "name": "search",
            "doc": "When specified only shows game titles that contain this string",
            "type": "string"
          },
          {
            "name": "sortBy",
            "doc": "",
            "type": "string"
          },
          {
            "name": "filters",
            "doc": "Filters",
            "type": "CavesFilters"
          },
          {
            "name": "reverse",
            "doc": "",
            "type": "boolean"
          },
          {
            "name": "cursor",
            "doc": "Used for pagination, if specified",
            "type": "Cursor"
          }
        ]
      },
      "result": {
        "fields": [
          {
            "name": "items",
            "doc": "",
            "type": "Cave[]"
          },
          {
            "name": "nextCursor",
            "doc": "Use to fetch the next 'page' of results",
            "type": "Cursor"
          }
        ]
      }
    },
    {
      "method": "Fetch.Cave",
      "doc": "Retrieve info on a cave by ID.",
      "caller": "client",
      "params": {
        "fields": [
          {
            "name": "caveId",
            "doc": "",
            "type": "string"
          }
        ]
      },
      "result": {
        "fields": [
          {
            "name": "cave",
            "doc": "",
            "type": "Cave"
          }
        ]
      }
    },
    {
      "method": "Fetch.CavesByGameID",
      "doc": "Retrieve all caves for a given game.",
      "caller": "client",
      "params": {
        "fields": [
          {
            "name": "gameId",
            "doc": "",
            "type": "number"
          }
        ]
      },
      "result": {
        "fields": [
          {
            "name": "caves",
            "doc": "",
            "type": "Cave[]"
          }
        ]
      }
    },
    {
      "method": "Fetch.CavesByInstallLocationID",
      "doc": "Retrieve all caves installed to a given location.",
      "caller": "client",
      "params": {
        "fields": [
          {
            "name": "installLocationId",
            "doc": "",
            "type": "string"
          }
        ]
      },
      "result": {
        "fields": [
          {
            "name": "installLocationPath",
            "doc": "",
            "type": "string"
          },
          {
            "name": "installLocationSize",
            "doc": "",
            "type": "number"
          },
          {
            "name": "caves",
            "doc": "",
            "type": "Cave[]"
          }
        ]
      }
    },
    {
      "method": "Fetch.ExpireAll",
      "doc": "Mark all local data as stale.",
      "caller": "client",
      "params": {
        "fields": null
      },
      "result": {
        "fields": null
      }
    },
    {
      "method": "Game.FindUploads",
      "doc": "Finds uploads compatible with the current runtime, for a given game.",
      "caller": "client",
      "params": {
        "fields": [
          {
            "name": "game",
            "doc": "Which game to find uploads for",
            "type": "Game"
          }
        ]
      },
      "result": {
        "fields": [
          {
            "name": "uploads",
            "doc": "A list of uploads that were found to be compatible.",
            "type": "Upload[]"
          }
        ]
      }
    },
    {
      "method": "Install.Queue",
      "doc": "Queues an install operation to be later performed\nvia @@InstallPerformParams.",
      "caller": "client",
      "params": {
        "fields": [
          {
            "name": "caveId",
            "doc": "ID of the cave to perform the install for.\nIf not specified, will create a new cave.",
            "type": "string"
          },
          {
            "name": "reason",
            "doc": "If unspecified, will default to 'install'",
            "type": "DownloadReason"
          },
          {
            "name": "installLocationId",
            "doc": "If CaveID is not specified, ID of an install location\nto install to.",
            "type": "string"
          },
          {
            "name": "noCave",
            "doc": "If set, InstallFolder can be set and no cave\nrecord will be read or modified",
            "type": "boolean"
          },
          {
            "name": "installFolder",
            "doc": "When NoCave is set, exactly where to install",
            "type": "string"
          },
          {
            "name": "game",
            "doc": "Which game to install.\n\nIf unspecified and caveId is specified, the same game will be used.",
            "type": "Game"
          },
          {
            "name": "upload",
            "doc": "Which upload to install.\n\nIf unspecified and caveId is specified, the same upload will be used.",
            "type": "Upload"
          },
          {
            "name": "build",
            "doc": "Which build to install\n\nIf unspecified and caveId is specified, the same build will be used.",
            "type": "Build"
          },
          {
            "name": "ignoreInstallers",
            "doc": "If true, do not run windows installers, just extract\nwhatever to the install folder.",
            "type": "boolean"
          },
          {
            "name": "stagingFolder",
            "doc": "A folder that butler can use to store temporary files, like\npartial downloads, checkpoint files, etc.",
            "type": "string"
          },
          {
            "name": "queueDownload",
            "doc": "If set, and the install operation is successfully disambiguated,\nwill queue it as a download for butler to drive.\nSee @@DownloadsDriveParams.",
            "type": "boolean"
          }
        ]
      },
      "result": {
        "fields": [
          {
            "name": "id",
            "doc": "",
            "type": "string"
          },
          {
            "name": "reason",
            "doc": "",
            "type": "DownloadReason"
          },
          {
            "name": "caveId",
            "doc": "",
            "type": "string"
          },
          {
            "name": "game",
            "doc": "",
            "type": "Game"
          },
          {
            "name": "upload",
            "doc": "",
            "type": "Upload"
          },
          {
            "name": "build",
            "doc": "",
            "type": "Build"
          },
          {
            "name": "installFolder",
            "doc": "",
            "type": "string"
          },
          {
            "name": "stagingFolder",
            "doc": "",
            "type": "string"
          }
        ]
      }
    },
    {
      "method": "ExternalUploadsAreBad",
      "doc": "Sent during @@InstallQueueParams.",
      "caller": "server",
      "params": {
        "fields": [
          {
            "name": "upload",
            "doc": "",
            "type": "Upload"
          }
        ]
      },
      "result": {
        "fields": [
          {
            "name": "whatever",
            "doc": "If true, will proceed with install anyway. Otherwise aborts.",
            "type": "boolean"
          }
        ]
      }
    },
    {
      "method": "Install.Perform",
      "doc": "Perform an install that was previously queued via\n@@InstallQueueParams.\n\nCan be cancelled by passing the same `ID` to @@InstallCancelParams.",
      "caller": "client",
      "params": {
        "fields": [
          {
            "name": "id",
            "doc": "ID that can be later used in @@InstallCancelParams",
            "type": "string"
          },
          {
            "name": "stagingFolder",
            "doc": "The folder turned by @@InstallQueueParams",
            "type": "string"
          }
        ]
      },
      "result": {
        "fields": null
      }
    },
    {
      "method": "Install.Cancel",
      "doc": "Attempt to gracefully cancel an ongoing operation.",
      "caller": "client",
      "params": {
        "fields": [
          {
            "name": "id",
            "doc": "The UUID of the task to cancel, as passed to @@OperationStartParams",
            "type": "string"
          }
        ]
      },
      "result": {
        "fields": [
          {
            "name": "didCancel",
            "doc": "",
            "type": "boolean"
          }
        ]
      }
    },
    {
      "method": "Uninstall.Perform",
      "doc": "UninstallParams contains all the parameters needed to perform\nan uninstallation for a game via @@OperationStartParams.",
      "caller": "client",
      "params": {
        "fields": [
          {
            "name": "caveId",
            "doc": "The cave to uninstall",
            "type": "string"
          }
        ]
      },
      "result": {
        "fields": null
      }
    },
    {
      "method": "Install.VersionSwitch.Queue",
      "doc": "Prepare to queue a version switch. The client will\nreceive an @@InstallVersionSwitchPickParams.",
      "caller": "client",
      "params": {
        "fields": [
          {
            "name": "caveId",
            "doc": "The cave to switch to a different version",
            "type": "string"
          }
        ]
      },
      "result": {
        "fields": null
      }
    },
    {
      "method": "InstallVersionSwitchPick",
      "doc": "Let the user pick which version to switch to.",
      "caller": "server",
      "params": {
        "fields": [
          {
            "name": "cave",
            "doc": "",
            "type": "Cave"
          },
          {
            "name": "upload",
            "doc": "",
            "type": "Upload"
          },
          {
            "name": "builds",
            "doc": "",
            "type": "Build[]"
          }
        ]
      },
      "result": {
        "fields": [
          {
            "name": "index",
            "doc": "A negative index aborts the version switch",
            "type": "number"
          }
        ]
      }
    },
    {
      "method": "PickUpload",
      "doc": "Asks the user to pick between multiple available uploads",
      "caller": "server",
      "params": {
        "fields": [
          {
            "name": "uploads",
            "doc": "An array of upload objects to choose from",
            "type": "Upload[]"
          }
        ]
      },
      "result": {
        "fields": [
          {
            "name": "index",
            "doc": "The index (in the original array) of the upload that was picked,\nor a negative value to cancel.",
            "type": "number"
          }
        ]
      }
    },
    {
      "method": "Install.Locations.List",
      "doc": "",
      "caller": "client",
      "params": {
        "fields": null
      },
      "result": {
        "fields": [
          {
            "name": "installLocations",
            "doc": "",
            "type": "InstallLocationSummary[]"
          }
        ]
      }
    },
    {
      "method": "Install.Locations.Add",
      "doc": "",
      "caller": "client",
      "params": {
        "fields": [
          {
            "name": "id",
            "doc": "identifier of the new install location.\nif not specified, will be generated.",
            "type": "string"
          },
          {
            "name": "path",
            "doc": "path of the new install location",
            "type": "string"
          }
        ]
      },
      "result": {
        "fields": null
      }
    },
    {
      "method": "Install.Locations.Remove",
      "doc": "",
      "caller": "client",
      "params": {
        "fields": [
          {
            "name": "id",
            "doc": "identifier of the install location to remove",
            "type": "string"
          }
        ]
      },
      "result": {
        "fields": null
      }
    },
    {
      "method": "Install.Locations.GetByID",
      "doc": "",
      "caller": "client",
      "params": {
        "fields": [
          {
            "name": "id",
            "doc": "identifier of the install location to remove",
            "type": "string"
          }
        ]
      },
      "result": {
        "fields": [
          {
            "name": "installLocation",
            "doc": "",
            "type": "InstallLocationSummary"
          }
        ]
      }
    },
    {
      "method": "Install.Locations.Scan",
      "doc": "",
      "caller": "client",
      "params": {
        "fields": [
          {
            "name": "legacyMarketPath",
            "doc": "path to a legacy marketDB",
            "type": "string"
          }
        ]
      },
      "result": {
        "fields": [
          {
            "name": "numFoundItems",
            "doc": "",
            "type": "number"
          },
          {
            "name": "numImportedItems",
            "doc": "",
            "type": "number"
          }
        ]
      }
    },
    {
      "method": "Install.Locations.Scan.ConfirmImport",
      "doc": "Sent at the end of @@InstallLocationsScanParams",
      "caller": "server",
      "params": {
        "fields": [
          {
            "name": "numItems",
            "doc": "number of items that will be imported",
            "type": "number"
          }
        ]
      },
      "result": {
        "fields": [
          {
            "name": "confirm",
            "doc": "",
            "type": "boolean"
          }
        ]
      }
    },
    {
      "method": "Downloads.Queue",
      "doc": "Queue a download that will be performed later by\n@@DownloadsDriveParams.",
      "caller": "client",
      "params": {
        "fields": [
          {
            "name": "item",
            "doc": "",
            "type": "InstallQueueResult"
          }
        ]
      },
      "result": {
        "fields": null
      }
    },
    {
      "method": "Downloads.Prioritize",
      "doc": "Put a download on top of the queue.",
      "caller": "client",
      "params": {
        "fields": [
          {
            "name": "downloadId",
            "doc": "",
            "type": "string"
          }
        ]
      },
      "result": {
        "fields": null
      }
    },
    {
      "method": "Downloads.List",
      "doc": "List all known downloads.",
      "caller": "client",
      "params": {
        "fields": null
      },
      "result": {
        "fields": [
          {
            "name": "downloads",
            "doc": "",
            "type": "Download[]"
          }
        ]
      }
    },
    {
      "method": "Downloads.ClearFinished",
      "doc": "Removes all finished downloads from the queue.",
      "caller": "client",
      "params": {
        "fields": null
      },
      "result": {
        "fields": null
      }
    },
    {
      "method": "Downloads.Drive",
      "doc": "Drive downloads, which is: perform them one at a time,\nuntil they're all finished.",
      "caller": "client",
      "params": {
        "fields": null
      },
      "result": {
        "fields": null
      }
    },
    {
      "method": "Downloads.Drive.Cancel",
      "doc": "Stop driving downloads gracefully.",
      "caller": "client",
      "params": {
        "fields": null
      },
      "result": {
        "fields": [
          {
            "name": "didCancel",
            "doc": "",
            "type": "boolean"
          }
        ]
      }
    },
    {
      "method": "Downloads.Retry",
      "doc": "Retries a download that has errored",
      "caller": "client",
      "params": {
        "fields": [
          {
            "name": "downloadId",
            "doc": "",
            "type": "string"
          }
        ]
      },
      "result": {
        "fields": null
      }
    },
    {
      "method": "Downloads.Discard",
      "doc": "Attempts to discard a download",
      "caller": "client",
      "params": {
        "fields": [
          {
            "name": "downloadId",
            "doc": "",
            "type": "string"
          }
        ]
      },
      "result": {
        "fields": null
      }
    },
    {
      "method": "CheckUpdate",
      "doc": "Looks for one or more game updates.\n\nUpdates found are regularly sent via @@GameUpdateAvailableNotification, and\nthen all at once in the result.",
      "caller": "client",
      "params": {
        "fields": [
          {
            "name": "items",
            "doc": "A list of items, each of it will be checked for updates",
            "type": "CheckUpdateItem[]"
          }
        ]
      },
      "result": {
        "fields": [
          {
            "name": "updates",
            "doc": "Any updates found (might be empty)",
            "type": "GameUpdate[]"
          },
          {
            "name": "warnings",
            "doc": "Warnings messages logged while looking for updates",
            "type": "string[]"
          }
        ]
      }
    },
    {
      "method": "Launch",
      "doc": "Attempt to launch an installed game.",
      "caller": "client",
      "params": {
        "fields": [
          {
            "name": "caveId",
            "doc": "The ID of the cave to launch",
            "type": "string"
          },
          {
            "name": "prereqsDir",
            "doc": "The directory to use to store installer files for prerequisites",
            "type": "string"
          },
          {
            "name": "forcePrereqs",
            "doc": "Force installing all prerequisites, even if they're already marked as installed",
            "type": "boolean"
          },
          {
            "name": "sandbox",
            "doc": "Enable sandbox (regardless of manifest opt-in)",
            "type": "boolean"
          }
        ]
      },
      "result": {
        "fields": null
      }
    },
    {
      "method": "Launch.Cancel",
      "doc": "Close a running game or cancel launching it",
      "caller": "client",
      "params": {
        "fields": null
      },
      "result": {
        "fields": [
          {
            "name": "didCancel",
            "doc": "",
            "type": "boolean"
          }
        ]
      }
    },
    {
      "method": "PickManifestAction",
      "doc": "Sent during @@LaunchParams, ask the user to pick a manifest action to launch.\n\nSee [itch app manifests](https://itch.io/docs/itch/integrating/manifest.html).",
      "caller": "server",
      "params": {
        "fields": [
          {
            "name": "actions",
            "doc": "A list of actions to pick from. Must be shown to the user in the order they're passed.",
            "type": "Action[]"
          }
        ]
      },
      "result": {
        "fields": [
          {
            "name": "index",
            "doc": "Index of action picked by user, or negative if aborting",
            "type": "number"
          }
        ]
      }
    },
    {
      "method": "ShellLaunch",
      "doc": "Ask the client to perform a shell launch, ie. open an item\nwith the operating system's default handler (File explorer).\n\nSent during @@LaunchParams.",
      "caller": "server",
      "params": {
        "fields": [
          {
            "name": "itemPath",
            "doc": "Absolute path of item to open, e.g. `D:\\\\Games\\\\Itch\\\\garden\\\\README.txt`",
            "type": "string"
          }
        ]
      },
      "result": {
        "fields": null
      }
    },
    {
      "method": "HTMLLaunch",
      "doc": "Ask the client to perform an HTML launch, ie. open an HTML5\ngame, ideally in an embedded browser.\n\nSent during @@LaunchParams.",
      "caller": "server",
      "params": {
        "fields": [
          {
            "name": "rootFolder",
            "doc": "Absolute path on disk to serve",
            "type": "string"
          },
          {
            "name": "indexPath",
            "doc": "Path of index file, relative to root folder",
            "type": "string"
          },
          {
            "name": "args",
            "doc": "Command-line arguments, to pass as `global.Itch.args`",
            "type": "string[]"
          },
          {
            "name": "env",
            "doc": "Environment variables, to pass as `global.Itch.env`",
            "type": "Map\u003cstring, string\u003e"
          }
        ]
      },
      "result": {
        "fields": null
      }
    },
    {
      "method": "URLLaunch",
      "doc": "Ask the client to perform an URL launch, ie. open an address\nwith the system browser or appropriate.\n\nSent during @@LaunchParams.",
      "caller": "server",
      "params": {
        "fields": [
          {
            "name": "url",
            "doc": "URL to open, e.g. `https://itch.io/community`",
            "type": "string"
          }
        ]
      },
      "result": {
        "fields": null
      }
    },
    {
      "method": "AllowSandboxSetup",
      "doc": "Ask the user to allow sandbox setup. Will be followed by\na UAC prompt (on Windows) or a pkexec dialog (on Linux) if\nthe user allows.\n\nSent during @@LaunchParams.",
      "caller": "server",
      "params": {
        "fields": null
      },
      "result": {
        "fields": [
          {
            "name": "allow",
            "doc": "Set to true if user allowed the sandbox setup, false otherwise",
            "type": "boolean"
          }
        ]
      }
    },
    {
      "method": "PrereqsFailed",
      "doc": "Sent during @@LaunchParams, when one or more prerequisites have failed to install.\nThe user may choose to proceed with the launch anyway.",
      "caller": "server",
      "params": {
        "fields": [
          {
            "name": "error",
            "doc": "Short error",
            "type": "string"
          },
          {
            "name": "errorStack",
            "doc": "Longer error (to include in logs)",
            "type": "string"
          }
        ]
      },
      "result": {
        "fields": [
          {
            "name": "continue",
            "doc": "Set to true if the user wants to proceed with the launch in spite of the prerequisites failure",
            "type": "boolean"
          }
        ]
      }
    },
    {
      "method": "CleanDownloads.Search",
      "doc": "Look for folders we can clean up in various download folders.\nThis finds anything that doesn't correspond to any current downloads\nwe know about.",
      "caller": "client",
      "params": {
        "fields": [
          {
            "name": "roots",
            "doc": "A list of folders to scan for potential subfolders to clean up",
            "type": "string[]"
          },
          {
            "name": "whitelist",
            "doc": "A list of subfolders to not consider when cleaning\n(staging folders for in-progress downloads)",
            "type": "string[]"
          }
        ]
      },
      "result": {
        "fields": [
          {
            "name": "entries",
            "doc": "Entries we found that could use some cleaning (with path and size information)",
            "type": "CleanDownloadsEntry[]"
          }
        ]
      }
    },
    {
      "method": "CleanDownloads.Apply",
      "doc": "Remove the specified entries from disk, freeing up disk space.",
      "caller": "client",
      "params": {
        "fields": [
          {
            "name": "entries",
            "doc": "",
            "type": "CleanDownloadsEntry[]"
          }
        ]
      },
      "result": {
        "fields": null
      }
    },
    {
      "method": "System.StatFS",
      "doc": "Get information on a filesystem.",
      "caller": "client",
      "params": {
        "fields": [
          {
            "name": "path",
            "doc": "",
            "type": "string"
          }
        ]
      },
      "result": {
        "fields": [
          {
            "name": "freeSize",
            "doc": "",
            "type": "number"
          },
          {
            "name": "totalSize",
            "doc": "",
            "type": "number"
          }
        ]
      }
    },
    {
      "method": "Test.DoubleTwice",
      "doc": "Test request: asks butler to double a number twice.\nFirst by calling @@TestDoubleParams, then by\nreturning the result of that call doubled.\n\nUse that to try out your JSON-RPC 2.0 over TCP implementation.",
      "caller": "client",
      "params": {
        "fields": [
          {
            "name": "number",
            "doc": "The number to quadruple",
            "type": "number"
          }
        ]
      },
      "result": {
        "fields": [
          {
            "name": "number",
            "doc": "The input, quadrupled",
            "type": "number"
          }
        ]
      }
    },
    {
      "method": "Test.Double",
      "doc": "Test request: return a number, doubled. Implement that to\nuse @@TestDoubleTwiceParams in your testing.",
      "caller": "server",
      "params": {
        "fields": [
          {
            "name": "number",
            "doc": "The number to double",
            "type": "number"
          }
        ]
      },
      "result": {
        "fields": [
          {
            "name": "number",
            "doc": "The number, doubled",
            "type": "number"
          }
        ]
      }
    }
  ],
  "notifications": [
    {
      "method": "Downloads.Drive.Progress",
      "doc": "",
      "params": {
        "fields": [
          {
            "name": "download",
            "doc": "",
            "type": "Download"
          },
          {
            "name": "progress",
            "doc": "",
            "type": "DownloadProgress"
          },
          {
            "name": "speedHistory",
            "doc": "BPS values for the last minute",
            "type": "number[]"
          }
        ]
      }
    },
    {
      "method": "Downloads.Drive.Started",
      "doc": "",
      "params": {
        "fields": [
          {
            "name": "download",
            "doc": "",
            "type": "Download"
          }
        ]
      }
    },
    {
      "method": "Downloads.Drive.Errored",
      "doc": "",
      "params": {
        "fields": [
          {
            "name": "download",
            "doc": "The download that errored. It contains all the error\ninformation: a short message, a full stack trace,\nand a butlerd error code.",
            "type": "Download"
          }
        ]
      }
    },
    {
      "method": "Downloads.Drive.Finished",
      "doc": "",
      "params": {
        "fields": [
          {
            "name": "download",
            "doc": "",
            "type": "Download"
          }
        ]
      }
    },
    {
      "method": "Downloads.Drive.Discarded",
      "doc": "",
      "params": {
        "fields": [
          {
            "name": "download",
            "doc": "",
            "type": "Download"
          }
        ]
      }
    },
    {
      "method": "Downloads.Drive.NetworkStatus",
      "doc": "Sent during @@DownloadsDriveParams to inform on network\nstatus changes.",
      "params": {
        "fields": [
          {
            "name": "status",
            "doc": "The current network status",
            "type": "NetworkStatus"
          }
        ]
      }
    },
    {
      "method": "Log",
      "doc": "Sent any time butler needs to send a log message. The client should\nrelay them in their own stdout / stderr, and collect them so they\ncan be part of an issue report if something goes wrong.",
      "params": {
        "fields": [
          {
            "name": "level",
            "doc": "Level of the message (`info`, `warn`, etc.)",
            "type": "LogLevel"
          },
          {
            "name": "message",
            "doc": "Contents of the message.\n\nNote: logs may contain non-ASCII characters, or even emojis.",
            "type": "string"
          }
        ]
      }
    },
    {
      "method": "SearchGamesYield",
      "doc": "Sent during @@SearchGamesParams",
      "params": {
        "fields": [
          {
            "name": "games",
            "doc": "",
            "type": "Game[]"
          }
        ]
      }
    },
    {
      "method": "SearchUsersYield",
      "doc": "Sent during @@SearchUsersParams when results are available",
      "params": {
        "fields": [
          {
            "name": "users",
            "doc": "",
            "type": "User[]"
          }
        ]
      }
    },
    {
      "method": "Progress",
      "doc": "Sent periodically during @@InstallPerformParams to inform on the current state of an install",
      "params": {
        "fields": [
          {
            "name": "progress",
            "doc": "An overall progress value between 0 and 1",
            "type": "number"
          },
          {
            "name": "eta",
            "doc": "Estimated completion time for the operation, in seconds (floating)",
            "type": "number"
          },
          {
            "name": "bps",
            "doc": "Network bandwidth used, in bytes per second (floating)",
            "type": "number"
          }
        ]
      }
    },
    {
      "method": "TaskStarted",
      "doc": "Each operation is made up of one or more tasks. This notification\nis sent during @@OperationStartParams whenever a specific task starts.",
      "params": {
        "fields": [
          {
            "name": "reason",
            "doc": "Why this task was started",
            "type": "TaskReason"
          },
          {
            "name": "type",
            "doc": "Is this task a download? An install?",
            "type": "TaskType"
          },
          {
            "name": "game",
            "doc": "The game this task is dealing with",
            "type": "Game"
          },
          {
            "name": "upload",
            "doc": "The upload this task is dealing with",
            "type": "Upload"
          },
          {
            "name": "build",
            "doc": "The build this task is dealing with (if any)",
            "type": "Build"
          },
          {
            "name": "totalSize",
            "doc": "Total size in bytes",
            "type": "number"
          }
        ]
      }
    },
    {
      "method": "TaskSucceeded",
      "doc": "Sent during @@OperationStartParams whenever a task succeeds for an operation.",
      "params": {
        "fields": [
          {
            "name": "type",
            "doc": "",
            "type": "TaskType"
          },
          {
            "name": "installResult",
            "doc": "If the task installed something, then this contains\ninfo about the game, upload, build that were installed",
            "type": "InstallResult"
          }
        ]
      }
    },
    {
      "method": "Install.Locations.Scan.Yield",
      "doc": "Sent during @@InstallLocationsScanParams whenever\na game is found.",
      "params": {
        "fields": [
          {
            "name": "game",
            "doc": "",
            "type": "Game"
          }
        ]
      }
    },
    {
      "method": "GameUpdateAvailable",
      "doc": "Sent during @@CheckUpdateParams, every time butler\nfinds an update for a game. Can be safely ignored if displaying\nupdates as they are found is not a requirement for the client.",
      "params": {
        "fields": [
          {
            "name": "update",
            "doc": "",
            "type": "GameUpdate"
          }
        ]
      }
    },
    {
      "method": "LaunchWindowShouldBeForeground",
      "doc": "Sent during @@LaunchParams, when attaching to a running\ninstance, instead of launching a new one.\n\nbutlerd will also try to call SetForegroundWindow itself\nbut since it's not the foreground process, it'll just\nbe highlighted in the task bar.\n\nWindows only.",
      "params": {
        "fields": [
          {
            "name": "hwnd",
            "doc": "An HWND of the window that should be brought to front\nusing SetForegrounWindow.",
            "type": "number"
          }
        ]
      }
    },
    {
      "method": "LaunchRunning",
      "doc": "Sent during @@LaunchParams, when the game is configured, prerequisites are installed\nsandbox is set up (if enabled), and the game is actually running.",
      "params": {
        "fields": null
      }
    },
    {
      "method": "LaunchExited",
      "doc": "Sent during @@LaunchParams, when the game has actually exited.",
      "params": {
        "fields": null
      }
    },
    {
      "method": "PrereqsStarted",
      "doc": "Sent during @@LaunchParams, when some prerequisites are about to be installed.\n\nThis is a good time to start showing a UI element with the state of prereq\ntasks.\n\nUpdates are regularly provided via @@PrereqsTaskStateNotification.",
      "params": {
        "fields": [
          {
            "name": "tasks",
            "doc": "A list of prereqs that need to be tended to",
            "type": "Map\u003cstring, PrereqTask\u003e"
          }
        ]
      }
    },
    {
      "method": "PrereqsTaskState",
      "doc": "Current status of a prerequisite task\n\nSent during @@LaunchParams, after @@PrereqsStartedNotification, repeatedly\nuntil all prereq tasks are done.",
      "params": {
        "fields": [
          {
            "name": "name",
            "doc": "Short name of the prerequisite task (e.g. `xna-4.0`)",
            "type": "string"
          },
          {
            "name": "status",
            "doc": "Current status of the prereq",
            "type": "PrereqStatus"
          },
          {
            "name": "progress",
            "doc": "Value between 0 and 1 (floating)",
            "type": "number"
          },
          {
            "name": "eta",
            "doc": "ETA in seconds (floating)",
            "type": "number"
          },
          {
            "name": "bps",
            "doc": "Network bandwidth used in bytes per second (floating)",
            "type": "number"
          }
        ]
      }
    },
    {
      "method": "PrereqsEnded",
      "doc": "Sent during @@LaunchParams, when all prereqs have finished installing (successfully or not)\n\nAfter this is received, it's safe to close any UI element showing prereq task state.",
      "params": {
        "fields": null
      }
    }
  ],
  "structTypes": [
    {
      "name": "Profile",
      "doc": "Represents a user for which we have profile information,\nie. that we can connect as, etc.",
      "fields": [
        {
          "name": "id",
          "doc": "itch.io user ID, doubling as profile ID",
          "type": "number"
        },
        {
          "name": "lastConnected",
          "doc": "Timestamp the user last connected at (to the client)",
          "type": "Date"
        },
        {
          "name": "user",
          "doc": "User information",
          "type": "User"
        }
      ]
    },
    {
      "name": "CollectionGamesFilters",
      "doc": "",
      "fields": [
        {
          "name": "installed",
          "doc": "",
          "type": "boolean"
        },
        {
          "name": "classification",
          "doc": "",
          "type": "GameClassification"
        }
      ]
    },
    {
      "name": "ProfileGameFilters",
      "doc": "",
      "fields": [
        {
          "name": "visibility",
          "doc": "",
          "type": "string"
        },
        {
          "name": "paidStatus",
          "doc": "",
          "type": "string"
        }
      ]
    },
    {
      "name": "ProfileGame",
      "doc": "",
      "fields": [
        {
          "name": "game",
          "doc": "",
          "type": "Game"
        },
        {
          "name": "viewsCount",
          "doc": "",
          "type": "number"
        },
        {
          "name": "downloadsCount",
          "doc": "",
          "type": "number"
        },
        {
          "name": "purchasesCount",
          "doc": "",
          "type": "number"
        },
        {
          "name": "published",
          "doc": "",
          "type": "boolean"
        }
      ]
    },
    {
      "name": "ProfileOwnedKeysFilters",
      "doc": "",
      "fields": [
        {
          "name": "installed",
          "doc": "",
          "type": "boolean"
        },
        {
          "name": "classification",
          "doc": "",
          "type": "GameClassification"
        }
      ]
    },
    {
      "name": "DownloadKeySummary",
      "doc": "",
      "fields": [
        {
          "name": "id",
          "doc": "Site-wide unique identifier generated by itch.io",
          "type": "number"
        },
        {
          "name": "gameId",
          "doc": "Identifier of the game to which this download key grants access",
          "type": "number"
        },
        {
          "name": "createdAt",
          "doc": "Date this key was created at (often coincides with purchase time)",
          "type": "Date"
        }
      ]
    },
    {
      "name": "CaveSummary",
      "doc": "",
      "fields": [
        {
          "name": "id",
          "doc": "",
          "type": "string"
        },
        {
          "name": "gameId",
          "doc": "",
          "type": "number"
        },
        {
          "name": "lastTouchedAt",
          "doc": "",
          "type": "Date"
        },
        {
          "name": "secondsRun",
          "doc": "",
          "type": "number"
        },
        {
          "name": "installedSize",
          "doc": "",
          "type": "number"
        }
      ]
    },
    {
      "name": "Cave",
      "doc": "",
      "fields": [
        {
          "name": "id",
          "doc": "",
          "type": "string"
        },
        {
          "name": "game",
          "doc": "",
          "type": "Game"
        },
        {
          "name": "upload",
          "doc": "",
          "type": "Upload"
        },
        {
          "name": "build",
          "doc": "",
          "type": "Build"
        },
        {
          "name": "stats",
          "doc": "",
          "type": "CaveStats"
        },
        {
          "name": "installInfo",
          "doc": "",
          "type": "CaveInstallInfo"
        }
      ]
    },
    {
      "name": "CaveStats",
      "doc": "",
      "fields": [
        {
          "name": "installedAt",
          "doc": "",
          "type": "Date"
        },
        {
          "name": "lastTouchedAt",
          "doc": "",
          "type": "Date"
        },
        {
          "name": "secondsRun",
          "doc": "",
          "type": "number"
        }
      ]
    },
    {
      "name": "CaveInstallInfo",
      "doc": "",
      "fields": [
        {
          "name": "installedSize",
          "doc": "",
          "type": "number"
        },
        {
          "name": "installLocation",
          "doc": "",
          "type": "string"
        },
        {
          "name": "installFolder",
          "doc": "",
          "type": "string"
        }
      ]
    },
    {
      "name": "InstallLocationSummary",
      "doc": "",
      "fields": [
        {
          "name": "id",
          "doc": "",
          "type": "string"
        },
        {
          "name": "path",
          "doc": "",
          "type": "string"
        },
        {
          "name": "sizeInfo",
          "doc": "",
          "type": "InstallLocationSizeInfo"
        }
      ]
    },
    {
      "name": "InstallLocationSizeInfo",
      "doc": "",
      "fields": [
        {
          "name": "installedSize",
          "doc": "Number of bytes used by caves installed in this location",
          "type": "number"
        },
        {
          "name": "freeSize",
          "doc": "Free space at this location (depends on the partition/disk on which\nit is), or a negative value if we can't find it",
          "type": "number"
        },
        {
          "name": "totalSize",
          "doc": "Total space of this location (depends on the partition/disk on which\nit is), or a negative value if we can't find it",
          "type": "number"
        }
      ]
    },
    {
      "name": "CavesFilters",
      "doc": "",
      "fields": [
        {
          "name": "classification",
          "doc": "",
          "type": "GameClassification"
        }
      ]
    },
    {
      "name": "GameCredentials",
      "doc": "GameCredentials contains all the credentials required to make API requests\nincluding the download key if any.",
      "fields": [
        {
          "name": "apiKey",
          "doc": "A valid itch.io API key",
          "type": "string"
        },
        {
          "name": "downloadKey",
          "doc": "A download key identifier, or 0 if no download key is available",
          "type": "number"
        }
      ]
    },
    {
      "name": "Download",
      "doc": "Represents a download queued, which will be\nperformed whenever @@DownloadsDriveParams is called.",
      "fields": [
        {
          "name": "id",
          "doc": "",
          "type": "string"
        },
        {
          "name": "error",
          "doc": "",
          "type": "string"
        },
        {
          "name": "errorMessage",
          "doc": "",
          "type": "string"
        },
        {
          "name": "errorCode",
          "doc": "",
          "type": "number"
        },
        {
          "name": "reason",
          "doc": "",
          "type": "DownloadReason"
        },
        {
          "name": "position",
          "doc": "",
          "type": "number"
        },
        {
          "name": "caveId",
          "doc": "",
          "type": "string"
        },
        {
          "name": "game",
          "doc": "",
          "type": "Game"
        },
        {
          "name": "upload",
          "doc": "",
          "type": "Upload"
        },
        {
          "name": "build",
          "doc": "",
          "type": "Build"
        },
        {
          "name": "startedAt",
          "doc": "",
          "type": "Date"
        },
        {
          "name": "finishedAt",
          "doc": "",
          "type": "Date"
        },
        {
          "name": "stagingFolder",
          "doc": "",
          "type": "string"
        }
      ]
    },
    {
      "name": "DownloadProgress",
      "doc": "",
      "fields": [
        {
          "name": "stage",
          "doc": "",
          "type": "string"
        },
        {
          "name": "progress",
          "doc": "",
          "type": "number"
        },
        {
          "name": "eta",
          "doc": "",
          "type": "number"
        },
        {
          "name": "bps",
          "doc": "",
          "type": "number"
        }
      ]
    },
    {
      "name": "Manifest",
      "doc": "A Manifest describes prerequisites (dependencies) and actions that\ncan be taken while launching a game.",
      "fields": [
        {
          "name": "actions",
          "doc": "Actions are a list of options to give the user when launching a game.",
          "type": "Action[]"
        },
        {
          "name": "prereqs",
          "doc": "Prereqs describe libraries or frameworks that must be installed\nprior to launching a game",
          "type": "Prereq[]"
        }
      ]
    },
    {
      "name": "Action",
      "doc": "An Action is a choice for the user to pick when launching a game.\n\nsee https://itch.io/docs/itch/integrating/manifest.html",
      "fields": [
        {
          "name": "name",
          "doc": "human-readable or standard name",
          "type": "string"
        },
        {
          "name": "path",
          "doc": "file path (relative to manifest or absolute), URL, etc.",
          "type": "string"
        },
        {
          "name": "icon",
          "doc": "icon name (see static/fonts/icomoon/demo.html, don't include `icon-` prefix)",
          "type": "string"
        },
        {
          "name": "args",
          "doc": "command-line arguments",
          "type": "string[]"
        },
        {
          "name": "sandbox",
          "doc": "sandbox opt-in",
          "type": "boolean"
        },
        {
          "name": "scope",
          "doc": "requested API scope",
          "type": "string"
        },
        {
          "name": "console",
          "doc": "don't redirect stdout/stderr, open in new console window",
          "type": "boolean"
        },
        {
          "name": "platform",
          "doc": "platform to restrict this action too",
          "type": "Platform"
        },
        {
          "name": "locales",
          "doc": "localized action name",
          "type": "Map\u003cstring, ActionLocale\u003e"
        }
      ]
    },
    {
      "name": "Prereq",
      "doc": "",
      "fields": [
        {
          "name": "name",
          "doc": "A prerequisite to be installed, see \u003chttps://itch.io/docs/itch/integrating/prereqs/\u003e for the full list.",
          "type": "string"
        }
      ]
    },
    {
      "name": "ActionLocale",
      "doc": "",
      "fields": [
        {
          "name": "name",
          "doc": "A localized action name",
          "type": "string"
        }
      ]
    },
    {
      "name": "User",
      "doc": "User represents an itch.io account, with basic profile info",
      "fields": [
        {
          "name": "id",
          "doc": "Site-wide unique identifier generated by itch.io",
          "type": "number"
        },
        {
          "name": "username",
          "doc": "The user's username (used for login)",
          "type": "string"
        },
        {
          "name": "displayName",
          "doc": "The user's display name: human-friendly, may contain spaces, unicode etc.",
          "type": "string"
        },
        {
          "name": "developer",
          "doc": "Has the user opted into creating games?",
          "type": "boolean"
        },
        {
          "name": "pressUser",
          "doc": "Is the user part of itch.io's press program?",
          "type": "boolean"
        },
        {
          "name": "url",
          "doc": "The address of the user's page on itch.io",
          "type": "string"
        },
        {
          "name": "coverUrl",
          "doc": "User's avatar, may be a GIF",
          "type": "string"
        },
        {
          "name": "stillCoverUrl",
          "doc": "Static version of user's avatar, only set if the main cover URL is a GIF",
          "type": "string"
        }
      ]
    },
    {
      "name": "Game",
      "doc": "Game represents a page on itch.io, it could be a game,\na tool, a comic, etc.",
      "fields": [
        {
          "name": "id",
          "doc": "Site-wide unique identifier generated by itch.io",
          "type": "number"
        },
        {
          "name": "url",
          "doc": "Canonical address of the game's page on itch.io",
          "type": "string"
        },
        {
          "name": "title",
          "doc": "Human-friendly title (may contain any character)",
          "type": "string"
        },
        {
          "name": "shortText",
          "doc": "Human-friendly short description",
          "type": "string"
        },
        {
          "name": "type",
          "doc": "Downloadable game, html game, etc.",
          "type": "GameType"
        },
        {
          "name": "classification",
          "doc": "Classification: game, tool, comic, etc.",
          "type": "GameClassification"
        },
        {
          "name": "embed",
          "doc": "Configuration for embedded (HTML5) games",
          "type": "GameEmbedData"
        },
        {
          "name": "coverUrl",
          "doc": "Cover url (might be a GIF)",
          "type": "string"
        },
        {
          "name": "stillCoverUrl",
          "doc": "Non-gif cover url, only set if main cover url is a GIF",
          "type": "string"
        },
        {
          "name": "createdAt",
          "doc": "Date the game was created",
          "type": "Date"
        },
        {
          "name": "publishedAt",
          "doc": "Date the game was published, empty if not currently published",
          "type": "Date"
        },
        {
          "name": "minPrice",
          "doc": "Price in cents of a dollar",
          "type": "number"
        },
        {
          "name": "canBeBought",
          "doc": "Are payments accepted?",
          "type": "boolean"
        },
        {
          "name": "hasDemo",
          "doc": "Does this game have a demo available?",
          "type": "boolean"
        },
        {
          "name": "inPressSystem",
          "doc": "Is this game part of the itch.io press system?",
          "type": "boolean"
        },
        {
          "name": "platforms",
          "doc": "Platforms this game is available for",
          "type": "Platforms"
        },
        {
          "name": "user",
          "doc": "The user account this game is associated to",
          "type": "User"
        },
        {
          "name": "userId",
          "doc": "ID of the user account this game is associated to",
          "type": "number"
        },
        {
          "name": "sale",
          "doc": "The best current sale for this game",
          "type": "Sale"
        },
        {
          "name": "viewsCount",
          "doc": "",
          "type": "number"
        },
        {
          "name": "downloadsCount",
          "doc": "",
          "type": "number"
        },
        {
          "name": "purchasesCount",
          "doc": "",
          "type": "number"
        },
        {
          "name": "published",
          "doc": "",
          "type": "boolean"
        }
      ]
    },
    {
      "name": "Platforms",
      "doc": "",
      "fields": [
        {
          "name": "windows",
          "doc": "",
          "type": "Architectures"
        },
        {
          "name": "linux",
          "doc": "",
          "type": "Architectures"
        },
        {
          "name": "osx",
          "doc": "",
          "type": "Architectures"
        }
      ]
    },
    {
      "name": "GameEmbedData",
      "doc": "Presentation information for embed games",
      "fields": [
        {
          "name": "gameId",
          "doc": "Game this embed info is for",
          "type": "number"
        },
        {
          "name": "width",
          "doc": "width of the initial viewport, in pixels",
          "type": "number"
        },
        {
          "name": "height",
          "doc": "height of the initial viewport, in pixels",
          "type": "number"
        },
        {
          "name": "fullscreen",
          "doc": "for itch.io website, whether or not a fullscreen button should be shown",
          "type": "boolean"
        }
      ]
    },
    {
      "name": "Sale",
      "doc": "Describes a discount for a game.",
      "fields": [
        {
          "name": "id",
          "doc": "Site-wide unique identifier generated by itch.io",
          "type": "number"
        },
        {
          "name": "gameId",
          "doc": "Game this sale is for",
          "type": "number"
        },
        {
          "name": "rate",
          "doc": "Discount rate in percent.\nCan be negative, see https://itch.io/updates/introducing-reverse-sales",
          "type": "number"
        },
        {
          "name": "startDate",
          "doc": "Timestamp the sale started at",
          "type": "string"
        },
        {
          "name": "endDate",
          "doc": "Timestamp the sale ends at",
          "type": "string"
        }
      ]
    },
    {
      "name": "Upload",
      "doc": "An Upload is a downloadable file. Some are wharf-enabled, which means\nthey're actually a \"channel\" that may contain multiple builds, pushed\nwith \u003chttps://github.com/itchio/butler\u003e",
      "fields": [
        {
          "name": "id",
          "doc": "Site-wide unique identifier generated by itch.io",
          "type": "number"
        },
        {
          "name": "filename",
          "doc": "Original file name (example: `Overland_x64.zip`)",
          "type": "string"
        },
        {
          "name": "displayName",
          "doc": "Human-friendly name set by developer (example: `Overland for Windows 64-bit`)",
          "type": "string"
        },
        {
          "name": "size",
          "doc": "Size of upload in bytes. For wharf-enabled uploads, it's the archive size.",
          "type": "number"
        },
        {
          "name": "channelName",
          "doc": "Name of the wharf channel for this upload, if it's a wharf-enabled upload",
          "type": "string"
        },
        {
          "name": "build",
          "doc": "Latest build for this upload, if it's a wharf-enabled upload",
          "type": "Build"
        },
        {
          "name": "type",
          "doc": "Upload type: default, soundtrack, etc.",
          "type": "UploadType"
        },
        {
          "name": "preorder",
          "doc": "Is this upload a pre-order placeholder?",
          "type": "boolean"
        },
        {
          "name": "demo",
          "doc": "Is this upload a free demo?",
          "type": "boolean"
        },
        {
          "name": "platforms",
          "doc": "Platforms this upload is compatible with",
          "type": "Platforms"
        },
        {
          "name": "createdAt",
          "doc": "Date this upload was created at",
          "type": "Date"
        },
        {
          "name": "updatedAt",
          "doc": "Date this upload was last updated at (order changed, display name set, etc.)",
          "type": "Date"
        }
      ]
    },
    {
      "name": "Collection",
      "doc": "A Collection is a set of games, curated by humans.",
      "fields": [
        {
          "name": "id",
          "doc": "Site-wide unique identifier generated by itch.io",
          "type": "number"
        },
        {
          "name": "title",
          "doc": "Human-friendly title for collection, for example `Couch coop games`",
          "type": "string"
        },
        {
          "name": "createdAt",
          "doc": "Date this collection was created at",
          "type": "Date"
        },
        {
          "name": "updatedAt",
          "doc": "Date this collection was last updated at (item added, title set, etc.)",
          "type": "Date"
        },
        {
          "name": "gamesCount",
          "doc": "Number of games in the collection. This might not be accurate\nas some games might not be accessible to whoever is asking (project\npage deleted, visibility level changed, etc.)",
          "type": "number"
        },
        {
          "name": "collectionGames",
          "doc": "Games in this collection, with additional info",
          "type": "CollectionGame[]"
        },
        {
          "name": "userId",
          "doc": "",
          "type": "number"
        },
        {
          "name": "user",
          "doc": "",
          "type": "User"
        }
      ]
    },
    {
      "name": "CollectionGame",
      "doc": "",
      "fields": [
        {
          "name": "collectionId",
          "doc": "",
          "type": "number"
        },
        {
          "name": "collection",
          "doc": "",
          "type": "Collection"
        },
        {
          "name": "gameId",
          "doc": "",
          "type": "number"
        },
        {
          "name": "game",
          "doc": "",
          "type": "Game"
        },
        {
          "name": "position",
          "doc": "",
          "type": "number"
        },
        {
          "name": "createdAt",
          "doc": "",
          "type": "Date"
        },
        {
          "name": "updatedAt",
          "doc": "",
          "type": "Date"
        },
        {
          "name": "blurb",
          "doc": "",
          "type": "string"
        },
        {
          "name": "userId",
          "doc": "",
          "type": "number"
        }
      ]
    },
    {
      "name": "DownloadKey",
      "doc": "A download key is often generated when a purchase is made, it\nallows downloading uploads for a game that are not available\nfor free.",
      "fields": [
        {
          "name": "id",
          "doc": "Site-wide unique identifier generated by itch.io",
          "type": "number"
        },
        {
          "name": "gameId",
          "doc": "Identifier of the game to which this download key grants access",
          "type": "number"
        },
        {
          "name": "game",
          "doc": "Game to which this download key grants access",
          "type": "Game"
        },
        {
          "name": "createdAt",
          "doc": "Date this key was created at (often coincides with purchase time)",
          "type": "Date"
        },
        {
          "name": "updatedAt",
          "doc": "Date this key was last updated at",
          "type": "Date"
        },
        {
          "name": "ownerId",
          "doc": "Identifier of the itch.io user to which this key belongs",
          "type": "number"
        }
      ]
    },
    {
      "name": "Build",
      "doc": "Build contains information about a specific build",
      "fields": [
        {
          "name": "id",
          "doc": "Site-wide unique identifier generated by itch.io",
          "type": "number"
        },
        {
          "name": "parentBuildId",
          "doc": "Identifier of the build before this one on the same channel,\nor 0 if this is the initial build.",
          "type": "number"
        },
        {
          "name": "state",
          "doc": "State of the build: started, processing, etc.",
          "type": "BuildState"
        },
        {
          "name": "version",
          "doc": "Automatically-incremented version number, starting with 1",
          "type": "number"
        },
        {
          "name": "userVersion",
          "doc": "Value specified by developer with `--userversion` when pushing a build\nMight not be unique across builds of a given channel.",
          "type": "string"
        },
        {
          "name": "files",
          "doc": "Files associated with this build - often at least an archive,\na signature, and a patch. Some might be missing while the build\nis still processing or if processing has failed.",
          "type": "BuildFile[]"
        },
        {
          "name": "user",
          "doc": "User who pushed the build",
          "type": "User"
        },
        {
          "name": "createdAt",
          "doc": "Timestamp the build was created at",
          "type": "Date"
        },
        {
          "name": "updatedAt",
          "doc": "Timestamp the build was last updated at",
          "type": "Date"
        }
      ]
    },
    {
      "name": "BuildFile",
      "doc": "BuildFile contains information about a build's \"file\", which could be its\narchive, its signature, its patch, etc.",
      "fields": [
        {
          "name": "id",
          "doc": "Site-wide unique identifier generated by itch.io",
          "type": "number"
        },
        {
          "name": "size",
          "doc": "Size of this build file",
          "type": "number"
        },
        {
          "name": "state",
          "doc": "State of this file: created, uploading, uploaded, etc.",
          "type": "BuildFileState"
        },
        {
          "name": "type",
          "doc": "Type of this build file: archive, signature, patch, etc.",
          "type": "BuildFileType"
        },
        {
          "name": "subType",
          "doc": "Subtype of this build file, usually indicates compression",
          "type": "BuildFileSubType"
        },
        {
          "name": "createdAt",
          "doc": "Date this build file was created at",
          "type": "Date"
        },
        {
          "name": "updatedAt",
          "doc": "Date this build file was last updated at",
          "type": "Date"
        }
      ]
    },
    {
      "name": "Verdict",
      "doc": "A Verdict contains a wealth of information on how to \"launch\" or \"open\" a specific\nfolder.",
      "fields": [
        {
          "name": "basePath",
          "doc": "BasePath is the absolute path of the folder that was configured",
          "type": "string"
        },
        {
          "name": "totalSize",
          "doc": "TotalSize is the size in bytes of the folder and all its children, recursively",
          "type": "number"
        },
        {
          "name": "candidates",
          "doc": "Candidates is a list of potentially interesting files, with a lot of additional info",
          "type": "Candidate[]"
        }
      ]
    },
    {
      "name": "Candidate",
      "doc": "A Candidate is a potentially interesting launch target, be it\na native executable, a Java or Love2D bundle, an HTML index, etc.",
      "fields": [
        {
          "name": "path",
          "doc": "Path is relative to the configured folder",
          "type": "string"
        },
        {
          "name": "mode",
          "doc": "Mode describes file permissions",
          "type": "number"
        },
        {
          "name": "depth",
          "doc": "Depth is the number of path elements leading up to this candidate",
          "type": "number"
        },
        {
          "name": "flavor",
          "doc": "Flavor is the type of a candidate - native, html, jar etc.",
          "type": "Flavor"
        },
        {
          "name": "arch",
          "doc": "Arch describes the architecture of a candidate (where relevant)",
          "type": "Arch"
        },
        {
          "name": "size",
          "doc": "Size is the size of the candidate's file, in bytes",
          "type": "number"
        },
        {
          "name": "spell",
          "doc": "Spell contains raw output from \u003chttps://github.com/itchio/wizardry\u003e",
          "type": "string[]"
        },
        {
          "name": "windowsInfo",
          "doc": "WindowsInfo contains information specific to native Windows candidates",
          "type": "WindowsInfo"
        },
        {
          "name": "linuxInfo",
          "doc": "LinuxInfo contains information specific to native Linux candidates",
          "type": "LinuxInfo"
        },
        {
          "name": "macosInfo",
          "doc": "MacosInfo contains information specific to native macOS candidates",
          "type": "MacosInfo"
        },
        {
          "name": "loveInfo",
          "doc": "LoveInfo contains information specific to Love2D bundles (`.love` files)",
          "type": "LoveInfo"
        },
        {
          "name": "scriptInfo",
          "doc": "ScriptInfo contains information specific to shell scripts (`.sh`, `.bat` etc.)",
          "type": "ScriptInfo"
        },
        {
          "name": "jarInfo",
          "doc": "JarInfo contains information specific to Java archives (`.jar` files)",
          "type": "JarInfo"
        }
      ]
    },
    {
      "name": "WindowsInfo",
      "doc": "Contains information specific to native windows executables\nor installer packages.",
      "fields": [
        {
          "name": "installerType",
          "doc": "Particular type of installer (msi, inno, etc.)",
          "type": "WindowsInstallerType"
        },
        {
          "name": "uninstaller",
          "doc": "True if we suspect this might be an uninstaller rather than an installer",
          "type": "boolean"
        },
        {
          "name": "gui",
          "doc": "Is this executable marked as GUI? This can be false and still pop a GUI, it's just a hint.",
          "type": "boolean"
        },
        {
          "name": "dotNet",
          "doc": "Is this a .NET assembly?",
          "type": "boolean"
        }
      ]
    },
    {
      "name": "MacosInfo",
      "doc": "Contains information specific to native macOS executables\nor app bundles.",
      "fields": null
    },
    {
      "name": "LinuxInfo",
      "doc": "Contains information specific to native Linux executables",
      "fields": null
    },
    {
      "name": "LoveInfo",
      "doc": "Contains information specific to Love2D bundles",
      "fields": [
        {
          "name": "version",
          "doc": "The version of love2D required to open this bundle. May be empty",
          "type": "string"
        }
      ]
    },
    {
      "name": "ScriptInfo",
      "doc": "Contains information specific to shell scripts",
      "fields": [
        {
          "name": "interpreter",
          "doc": "Something like `/bin/bash`",
          "type": "string"
        }
      ]
    },
    {
      "name": "JarInfo",
      "doc": "Contains information specific to Java archives",
      "fields": [
        {
          "name": "mainClass",
          "doc": "The main Java class as specified by the manifest included in the .jar (if any)",
          "type": "string"
        }
      ]
    },
    {
      "name": "Receipt",
      "doc": "A Receipt describes what was installed to a specific folder.\n\nIt's compressed and written to `./.itch/receipt.json.gz` every\ntime an install operation completes successfully, and is used\nin further install operations to make sure ghosts are busted and/or\nangels are saved.",
      "fields": [
        {
          "name": "game",
          "doc": "The itch.io game installed at this location",
          "type": "Game"
        },
        {
          "name": "upload",
          "doc": "The itch.io upload installed at this location",
          "type": "Upload"
        },
        {
          "name": "build",
          "doc": "The itch.io build installed at this location. Null for non-wharf upload.",
          "type": "Build"
        },
        {
          "name": "files",
          "doc": "A list of installed files (slash-separated paths, relative to install folder)",
          "type": "string[]"
        },
        {
          "name": "installerName",
          "doc": "The installer used to install at this location",
          "type": "string"
        },
        {
          "name": "msiProductCode",
          "doc": "If this was installed from an MSI package, the product code,\nused for a clean uninstall.",
          "type": "string"
        }
      ]
    },
    {
      "name": "InstallResult",
      "doc": "What was installed by a subtask of @@OperationStartParams.\n\nSee @@TaskSucceededNotification.",
      "fields": [
        {
          "name": "game",
          "doc": "The game we installed",
          "type": "Game"
        },
        {
          "name": "upload",
          "doc": "The upload we installed",
          "type": "Upload"
        },
        {
          "name": "build",
          "doc": "The build we installed",
          "type": "Build"
        }
      ]
    },
    {
      "name": "CheckUpdateItem",
      "doc": "",
      "fields": [
        {
          "name": "itemId",
          "doc": "An UUID generated by the client, which allows it to map back the\nresults to its own items.",
          "type": "string"
        },
        {
          "name": "installedAt",
          "doc": "Timestamp of the last successful install operation",
          "type": "Date"
        },
        {
          "name": "game",
          "doc": "Game for which to look for an update",
          "type": "Game"
        },
        {
          "name": "upload",
          "doc": "Currently installed upload",
          "type": "Upload"
        },
        {
          "name": "build",
          "doc": "Currently installed build",
          "type": "Build"
        }
      ]
    },
    {
      "name": "GameUpdate",
      "doc": "Describes an available update for a particular game install.",
      "fields": [
        {
          "name": "itemId",
          "doc": "Identifier originally passed in CheckUpdateItem",
          "type": "string"
        },
        {
          "name": "game",
          "doc": "Game we found an update for",
          "type": "Game"
        },
        {
          "name": "upload",
          "doc": "Upload to be installed",
          "type": "Upload"
        },
        {
          "name": "build",
          "doc": "Build to be installed (may be nil)",
          "type": "Build"
        }
      ]
    },
    {
      "name": "PrereqTask",
      "doc": "Information about a prerequisite task.",
      "fields": [
        {
          "name": "fullName",
          "doc": "Full name of the prerequisite, for example: `Microsoft .NET Framework 4.6.2`",
          "type": "string"
        },
        {
          "name": "order",
          "doc": "Order of task in the list. Respect this order in the UI if you want consistent progress indicators.",
          "type": "number"
        }
      ]
    },
    {
      "name": "CleanDownloadsEntry",
      "doc": "",
      "fields": [
        {
          "name": "path",
          "doc": "The complete path of the file or folder we intend to remove",
          "type": "string"
        },
        {
          "name": "size",
          "doc": "The size of the folder or file, in bytes",
          "type": "number"
        }
      ]
    }
  ],
  "enumTypes": null
}
